generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// NextAuth.js models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// User model
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  username      String?   @unique
  bio           String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts       Account[]
  sessions       Session[]
  reviews        Review[]
  userFragrances UserFragrance[]
  lists          List[]
  activities     Activity[]
  reviewLikes    ReviewLike[]
  followers      UserFollow[]    @relation("Following")
  following      UserFollow[]    @relation("Follower")
}

// Brand model
model Brand {
  id          String      @id @default(cuid())
  name        String
  slug        String      @unique
  country     String?
  description String?
  logo        String?
  website     String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  fragrances  Fragrance[]
}

// Fragrance concentration types - SQLite doesn't support enums natively
// Using String with validation at application level

// Fragrance model
model Fragrance {
  id            String   @id @default(cuid())
  name          String
  slug          String   @unique
  brandId       String
  concentration String   @default("EAU_DE_PARFUM")
  gender        String   @default("UNISEX")
  releaseYear   Int?
  description   String?
  image         String?
  averageRating Float    @default(0)
  reviewCount   Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  brand          Brand           @relation(fields: [brandId], references: [id])
  notes          FragranceNote[]
  reviews        Review[]
  userFragrances UserFragrance[]
  listItems      ListItem[]
  activities     Activity[]
}

// Note model
model Note {
  id          String          @id @default(cuid())
  name        String
  slug        String          @unique
  category    String
  description String?
  fragrances  FragranceNote[]
}

// Junction table for fragrance notes
model FragranceNote {
  id          String @id @default(cuid())
  fragranceId String
  noteId      String
  layer       String

  fragrance Fragrance @relation(fields: [fragranceId], references: [id], onDelete: Cascade)
  note      Note      @relation(fields: [noteId], references: [id], onDelete: Cascade)

  @@unique([fragranceId, noteId])
}

// User's fragrance collection
model UserFragrance {
  id          String   @id @default(cuid())
  userId      String
  fragranceId String
  status      String
  rating      Int?
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  fragrance Fragrance @relation(fields: [fragranceId], references: [id], onDelete: Cascade)

  @@unique([userId, fragranceId])
}

// Review model
model Review {
  id          String   @id @default(cuid())
  userId      String
  fragranceId String
  rating      Int
  content     String
  longevity   Int?
  sillage     Int?
  value       Int?
  season      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  fragrance  Fragrance    @relation(fields: [fragranceId], references: [id], onDelete: Cascade)
  likes      ReviewLike[]
  activities Activity[]

  @@unique([userId, fragranceId])
}

// Review likes
model ReviewLike {
  id        String   @id @default(cuid())
  userId    String
  reviewId  String
  createdAt DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  @@unique([userId, reviewId])
}

// User lists
model List {
  id          String     @id @default(cuid())
  userId      String
  name        String
  slug        String
  description String?
  isPublic    Boolean    @default(true)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  items ListItem[]

  @@unique([userId, slug])
}

// List items
model ListItem {
  id          String   @id @default(cuid())
  listId      String
  fragranceId String
  position    Int
  notes       String?
  createdAt   DateTime @default(now())

  list      List      @relation(fields: [listId], references: [id], onDelete: Cascade)
  fragrance Fragrance @relation(fields: [fragranceId], references: [id], onDelete: Cascade)

  @@unique([listId, fragranceId])
}

// User follow relationship
model UserFollow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower  User @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
}

// Activity feed
model Activity {
  id           String   @id @default(cuid())
  userId       String
  type         String
  fragranceId  String?
  reviewId     String?
  targetUserId String?
  listId       String?
  createdAt    DateTime @default(now())

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  fragrance Fragrance? @relation(fields: [fragranceId], references: [id], onDelete: Cascade)
  review    Review?    @relation(fields: [reviewId], references: [id], onDelete: Cascade)
}
